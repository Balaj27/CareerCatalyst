import { GoogleGenerativeAI } from "@google/generative-ai";

const apiKey: string = "AIzaSyDyU0GXBc4pkQQLNJrwlSxNA1GZnK6XGOY";
const genAI = new GoogleGenerativeAI(apiKey);

const model = genAI.getGenerativeModel({
  model: "gemini-2.5-flash-lite",
});

const generationConfig = {
  temperature: 1,
  topP: 0.95,
  topK: 64,
  maxOutputTokens: 8192,
  responseMimeType: "application/json",
};

interface Question {
  id: number;
  question: string;
  options: string[];
  correctAnswer: number;
  explanation: string;
}

interface InterviewResponse {
  question: string;
  answer: string;
  duration: number;
}

interface AnalysisResult {
  overallScore: number;
  confidence: "High" | "Medium" | "Low";
  tone: "Professional" | "Confident" | "Nervous" | "Casual";
  answerQuality: "Excellent" | "Good" | "Satisfactory" | "Needs Improvement";
  strengths: string[];
  improvements: string[];
  feedback: string;
  technicalKnowledge: string;
  communicationSkills: string;
  responseTime: string;
  readinessLevel: "Ready for Role" | "Needs More Practice" | "Requires Significant Development";
  keyInsights: string;
  specificRecommendations: string;
}

type DifficultyLevel = "junior" | "beginner" | "mid" | "intermediate" | "senior" | "advanced";

// Generate unique MCQ questions using AI with robust validation
export const generateMCQs = async (jobTitle: string, difficulty: string, count: number): Promise<Question[]> => {
  try {
    // Create unique context for each generation
    const timestamp: number = Date.now();
    const randomElements: string = Math.random().toString(36).substring(2, 15);
    const sessionId: string = `${timestamp}_${randomElements}`;

    const prompt: string = `Generate ${count} completely unique and different multiple choice questions for "${jobTitle}" role interview.

CRITICAL REQUIREMENTS:
üéØ Job Role: ${jobTitle}
üìä Difficulty: ${difficulty}  
üîÑ Session ID: ${sessionId} (ensure this generates unique questions every time)
‚ö° Make each question completely different from standard templates

STRICT JSON FORMAT REQUIREMENTS:
- Each question MUST have exactly 4 options
- correctAnswer MUST be a number: 0, 1, 2, or 3 (NEVER any other value)
- All fields are required and must be strings except correctAnswer (number)

UNIQUENESS RULES:
- Each question must test different skills/knowledge areas for ${jobTitle}
- Use varied question formats (scenario, design principles, tools, best practices, user research)
- Include real-world situations specific to ${jobTitle}
- Mix theoretical knowledge with practical application
- Reference current technologies and methodologies relevant to ${jobTitle}

FOR ${jobTitle.toUpperCase()} ROLE, FOCUS ON:
${getFieldSpecificGuidelines(jobTitle, difficulty)}

EXAMPLE STRUCTURE (follow exactly):
[
  {
    "id": 1,
    "question": "When designing a mobile app interface for ${jobTitle}, what is the most important consideration for thumb-friendly navigation?",
    "options": ["Option A with specific details", "Option B with specific details", "Option C with specific details", "Option D with specific details"],
    "correctAnswer": 2,
    "explanation": "Detailed explanation why option C is correct for ${jobTitle} professionals"
  }
]

VALIDATION RULES:
- correctAnswer MUST be 0, 1, 2, or 3 only
- Each option must be different and specific
- Question must be specific to ${jobTitle}, not generic
- All text must be professional and clear

Generate ${count} completely different questions following this exact format!`;

    console.log(`üöÄ Generating ${count} unique questions for ${jobTitle} (${difficulty})...`);

    const chatSession = model.startChat({
      generationConfig,
      history: [],
    });

    const result = await chatSession.sendMessage(prompt);
    const response = await result.response;
    const text: string = response.text();

    console.log(`üìù AI Response received for ${jobTitle}`);

    // Parse the AI response with robust cleaning
    let cleanedText: string = text.trim();
    
    // Remove markdown formatting if present
    if (cleanedText.includes('```json')) {
      cleanedText = cleanedText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
    } else if (cleanedText.includes('```')) {
      cleanedText = cleanedText.replace(/```\s*/g, '');
    }

    // Remove any extra text before or after JSON
    const jsonStart: number = cleanedText.indexOf('[');
    const jsonEnd: number = cleanedText.lastIndexOf(']');
    
    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
      cleanedText = cleanedText.substring(jsonStart, jsonEnd + 1);
    }

    try {
      const rawQuestions: any[] = JSON.parse(cleanedText);

      // Validate response is array
      if (!Array.isArray(rawQuestions)) {
        throw new Error(`Response is not an array: ${typeof rawQuestions}`);
      }

      if (rawQuestions.length === 0) {
        throw new Error('No questions generated by AI');
      }

      console.log(`üìã Processing ${rawQuestions.length} questions from AI...`);

      // Process and validate each question with auto-fixing
      const validQuestions: Question[] = rawQuestions.slice(0, count).map((q: any, index: number): Question => {
        // Validate and fix question structure
        if (!q.question || typeof q.question !== 'string' || q.question.trim() === '') {
          throw new Error(`Invalid or empty question at index ${index}`);
        }

        if (!Array.isArray(q.options)) {
          throw new Error(`Options is not an array at index ${index}`);
        }

        // Ensure exactly 4 options
        if (q.options.length !== 4) {
          throw new Error(`Question ${index} has ${q.options.length} options, must have exactly 4`);
        }

        // Validate each option
        q.options.forEach((option: any, optIndex: number) => {
          if (!option || typeof option !== 'string' || option.trim() === '') {
            throw new Error(`Invalid option ${optIndex} at question ${index}`);
          }
        });

        // Fix correctAnswer validation - this is the key fix!
        let correctAnswer: number = q.correctAnswer;
        
        // Convert string numbers to integers
        if (typeof correctAnswer === 'string') {
          correctAnswer = parseInt(correctAnswer, 10);
        }
        
        // Validate correctAnswer is a valid number
        if (typeof correctAnswer !== 'number' || isNaN(correctAnswer)) {
          console.warn(`‚ö†Ô∏è Invalid correctAnswer at index ${index}: ${q.correctAnswer}, defaulting to 0`);
          correctAnswer = 0;
        }
        
        // Ensure correctAnswer is in valid range (0-3)
        if (correctAnswer < 0 || correctAnswer > 3) {
          console.warn(`‚ö†Ô∏è correctAnswer ${correctAnswer} out of range at index ${index}, fixing to ${correctAnswer % 4}`);
          correctAnswer = Math.abs(correctAnswer % 4); // Fix to valid range
        }

        if (!q.explanation || typeof q.explanation !== 'string' || q.explanation.trim() === '') {
          console.warn(`‚ö†Ô∏è Missing explanation at index ${index}, generating default`);
          q.explanation = `This is the correct answer for ${jobTitle} professionals based on industry best practices.`;
        }

        return {
          id: index + 1,
          question: q.question.trim(),
          options: q.options.map((opt: string) => opt.trim()),
          correctAnswer: correctAnswer,
          explanation: q.explanation.trim()
        };
      });

      console.log(`‚úÖ Successfully processed ${validQuestions.length} valid questions for ${jobTitle}`);
      
      // Log sample question for debugging
      if (validQuestions.length > 0) {
        console.log(`üìù Sample question: "${validQuestions[0].question.substring(0, 50)}..."`);
        console.log(`üéØ Correct answer index: ${validQuestions[0].correctAnswer}`);
      }

      return validQuestions;

    } catch (parseError: any) {
      console.error(`‚ùå Parse error for ${jobTitle}:`, parseError);
      console.error('Raw response (first 500 chars):', text.substring(0, 500));
      console.error('Cleaned text (first 500 chars):', cleanedText.substring(0, 500));
      throw new Error(`Failed to parse AI response: ${parseError.message}`);
    }

  } catch (error: any) {
    console.error(`üí• Error generating questions for ${jobTitle}:`, error);
    throw new Error(`Failed to generate questions: ${error.message}`);
  }
};

// Get field-specific guidelines for the AI prompt
function getFieldSpecificGuidelines(jobTitle: string, difficulty: string): string {
  const role: string = jobTitle.toLowerCase();
  
  if (role.includes('ui') || role.includes('ux') || role.includes('designer')) {
    return `
- User research methods and usability testing
- Design systems and component libraries  
- Wireframing and prototyping tools (Figma, Sketch, Adobe XD)
- Information architecture and user flows
- Visual design principles and accessibility (WCAG)
- Design thinking methodology and user personas
- Interaction design and micro-interactions
- Mobile-first and responsive design principles
- Color theory, typography, and visual hierarchy
- User testing and feedback incorporation
- Collaboration with developers and stakeholders
- Design handoff and documentation practices`;
  }
  
  if (role.includes('software') || role.includes('developer') || role.includes('programmer')) {
    return `
- Programming languages, frameworks, and tools
- Code quality, testing, and debugging techniques
- System architecture and design patterns
- Database design and optimization strategies
- API development and integration methods
- Security best practices and implementation
- Performance optimization and scalability`;
  }
  
  if (role.includes('data scientist') || role.includes('data analyst')) {
    return `
- Machine learning algorithms and model selection
- Statistical analysis and hypothesis testing methods
- Data preprocessing and feature engineering techniques
- Python/R libraries (pandas, scikit-learn, numpy)
- Data visualization and storytelling with data
- Model evaluation, validation, and deployment
- Big data technologies and cloud platforms`;
  }
  
  if (role.includes('devops') || role.includes('sre') || role.includes('infrastructure')) {
    return `
- Cloud platforms (AWS, Azure, GCP) and services
- Container orchestration (Docker, Kubernetes)
- Infrastructure as Code (Terraform, CloudFormation)
- CI/CD pipelines and automation tools
- Monitoring, logging, and alerting systems
- Security and compliance frameworks
- System scalability and reliability engineering`;
  }
  
  if (role.includes('frontend') || role.includes('react') || role.includes('vue')) {
    return `
- Modern JavaScript/TypeScript frameworks and libraries
- Responsive design and CSS methodologies
- Web performance optimization techniques
- Browser compatibility and cross-platform testing
- State management and component architecture
- Accessibility standards and implementation
- Build tools and development workflow optimization`;
  }
  
  if (role.includes('backend') || role.includes('api') || role.includes('server')) {
    return `
- Server-side technologies and framework selection
- Database design and query optimization
- API design patterns and microservices architecture
- Caching strategies and performance optimization
- Security implementation and authentication methods
- Scalability planning and load balancing
- Message queues and asynchronous processing`;
  }
  
  if (role.includes('product manager') || role.includes('pm')) {
    return `
- Product strategy development and roadmap planning
- User research methodologies and market analysis
- Agile methodologies and project management frameworks
- Stakeholder communication and alignment strategies
- Feature prioritization frameworks and decision-making
- Metrics definition, KPI tracking, and analytics
- A/B testing design and data-driven decision making`;
  }
  
  if (role.includes('security') || role.includes('cybersecurity')) {
    return `
- Threat analysis and risk assessment methodologies
- Security frameworks and compliance requirements
- Penetration testing and vulnerability assessment
- Incident response and digital forensics
- Network security and monitoring systems
- Identity and access management solutions
- Security tools and threat detection technologies`;
  }
  
  // Generic tech role guidelines
  return `
- Technical problem-solving methodologies
- Industry best practices and current standards
- Team collaboration and communication strategies
- Technology trends and innovation adoption
- Project management and delivery methodologies
- Quality assurance and testing approaches
- Professional development and continuous learning`;
}

// Generate interview questions for voice interview
export const generateInterviewQuestions = async (
  jobTitle: string,
  difficulty: string,
  count: number = 8,
): Promise<string[]> => {
  try {
    const timestamp: number = Date.now();
    const randomSeed: string = Math.random().toString(36).substring(2, 10);
    const uniqueId: string = `${timestamp}_${randomSeed}`;

    const prompt: string = `Generate ${count} unique interview questions for "${jobTitle}" position at ${difficulty} level.

UNIQUENESS REQUIREMENTS:
üîÑ Unique Session: ${uniqueId}
üéØ Role: ${jobTitle}
üìä Level: ${difficulty}
‚≠ê Generate completely different questions each time this is called

QUESTION TYPES TO INCLUDE:
1. Technical expertise and hands-on experience
2. Problem-solving scenarios specific to ${jobTitle}
3. Past project challenges and creative solutions
4. Behavioral and team collaboration situations
5. Leadership and mentorship experiences
6. Industry knowledge and emerging trends
7. Career motivation and professional growth
8. Role-specific challenges and methodologies

${getInterviewGuidelines(jobTitle, difficulty)}

REQUIREMENTS:
- Each question should encourage detailed storytelling
- Mix technical depth with behavioral insights
- Include hypothetical scenarios and real-world problems
- Questions should reveal thought processes and approach
- Natural conversation flow for voice interviews
- Specific to ${jobTitle} responsibilities and challenges

Return ONLY a JSON array of question strings:
["Question 1 about specific ${jobTitle} experience?", "Question 2 about ${jobTitle} challenges?", ...]

Make every question unique, engaging, and ${jobTitle}-specific!`;

    const chatSession = model.startChat({
      generationConfig: {
        ...generationConfig,
        temperature: 1.2,
      },
      history: [],
    });

    const result = await chatSession.sendMessage(prompt);
    const response = await result.response;
    let text: string = response.text().trim();

    // Clean response
    if (text.includes('```json')) {
      text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '');
    } else if (text.includes('```')) {
      text = text.replace(/```\s*/g, '');
    }

    const questions: string[] = JSON.parse(text);
    
    if (!Array.isArray(questions) || questions.length === 0) {
      throw new Error('Invalid questions format');
    }

    console.log(`‚úÖ Generated ${questions.length} unique interview questions for ${jobTitle}`);
    return questions.slice(0, count);

  } catch (error: any) {
    console.error(`‚ùå Error generating interview questions for ${jobTitle}:`, error);
    throw new Error(`Failed to generate interview questions: ${error.message}`);
  }
};

// Get interview-specific guidelines
function getInterviewGuidelines(jobTitle: string, difficulty: string): string {
  const level: string = difficulty.toLowerCase();
  
  let guidelines: string = `
DIFFICULTY-SPECIFIC FOCUS (${difficulty.toUpperCase()} LEVEL):
`;
  
  if (level === 'junior' || level === 'beginner') {
    guidelines += `
- Learning ability and growth mindset demonstration
- Basic technical skills and fundamental knowledge
- Educational projects, internships, and personal projects
- Enthusiasm and motivation to learn and grow
- Problem-solving approach for straightforward challenges
- Teamwork and communication in learning environments`;
  } else if (level === 'mid' || level === 'intermediate') {
    guidelines += `
- Proven professional experience and measurable achievements
- Complex problem-solving and strategic decision-making
- Team collaboration, mentorship, and knowledge sharing
- Technical leadership in projects and initiatives
- Process improvement and optimization contributions
- Cross-functional collaboration and communication`;
  } else if (level === 'senior' || level === 'advanced') {
    guidelines += `
- Strategic thinking and high-level architectural decisions
- Cross-functional leadership and organizational influence
- Mentoring, coaching, and team development activities
- Business impact measurement and stakeholder management
- Innovation leadership and technology evolution guidance
- Industry thought leadership and community contributions`;
  }

  return guidelines;
}

// Analyze interview performance with enhanced analysis
export const analyzeInterviewPerformance = async (
  jobTitle: string,
  difficulty: string,
  responses: InterviewResponse[],
): Promise<AnalysisResult> => {
  try {
    const uniqueAnalysisId: string = `${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
    
    const responsesData = responses.map((r: InterviewResponse, i: number) => ({
      questionNumber: i + 1,
      question: r.question,
      answer: r.answer || "No response provided",
      duration: Math.round(r.duration / 1000),
      wordCount: r.answer ? r.answer.split(' ').filter(word => word.length > 0).length : 0
    }));

    const prompt: string = `Analyze this ${jobTitle} interview performance (${difficulty} level):

ANALYSIS SESSION: ${uniqueAnalysisId}
ROLE: ${jobTitle}
LEVEL: ${difficulty}

INTERVIEW RESPONSES:
${responsesData.map(r => `
Question ${r.questionNumber}: ${r.question}
Response: ${r.answer}
Duration: ${r.duration} seconds
Word Count: ${r.wordCount} words
---`).join('\n')}

ANALYSIS REQUIREMENTS:
Provide comprehensive, constructive analysis focusing on:
- Technical competency for ${jobTitle} role
- Communication effectiveness and clarity
- Problem-solving approach and methodology
- Professional experience demonstration
- Confidence and presentation skills
- Role-specific knowledge and insights
- Areas of strength and improvement opportunities

Return analysis in this EXACT JSON format:
{
  "overallScore": 78,
  "confidence": "High|Medium|Low",
  "tone": "Professional|Confident|Nervous|Casual",
  "answerQuality": "Excellent|Good|Satisfactory|Needs Improvement",
  "strengths": ["Specific strength 1", "Specific strength 2", "Specific strength 3"],
  "improvements": ["Specific improvement 1", "Specific improvement 2", "Specific improvement 3"],
  "feedback": "Detailed 2-3 sentence constructive feedback paragraph",
  "technicalKnowledge": "Assessment of technical skills demonstrated",
  "communicationSkills": "Evaluation of communication effectiveness",
  "responseTime": "Analysis of response pacing and timing",
  "readinessLevel": "Ready for Role|Needs More Practice|Requires Significant Development",
  "keyInsights": "Most notable observations about the candidate",
  "specificRecommendations": "Actionable steps for improvement"
}

Provide honest, specific, and actionable feedback for ${jobTitle} role preparation.`;

    const chatSession = model.startChat({
      generationConfig: {
        ...generationConfig,
        temperature: 0.7,
      },
      history: [],
    });

    const result = await chatSession.sendMessage(prompt);
    const response = await result.response;
    let text: string = response.text().trim();

    // Clean response
    if (text.includes('```json')) {
      text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '');
    }

    const analysis: AnalysisResult = JSON.parse(text);
    console.log(`‚úÖ Generated analysis for ${jobTitle} interview`);
    return analysis;

  } catch (error: any) {
    console.error(`‚ùå Error analyzing interview performance:`, error);
    throw new Error(`Failed to analyze performance: ${error.message}`);
  }
};